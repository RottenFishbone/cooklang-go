// THIS FILE IS AUTOMATICALLY GENERATED BY `internal/cmd/test_gen` DO NOT EDIT

package cook

import (
	"fmt"
	"reflect"
	"testing"
)

// --------------------------------------------------------------
// Canonical Unit Tests
//
// NOTE: I did ignore `Qty: "some"` for one word ingredients and `Qty: 1` for 
// one word cookware. It's trivial to add, however, it is a little weird for 
// some ingredients and some cookware i.e. "some egg" or "1 tongs".
//
// It's also presumptious of usage for non-english languages.
// I'm going to leave it to the projects interfacing this parser to work that 
// out as they see fit.
//
// Tests are defined here:
// https://github.com/cooklang/spec/tree/fa9bc51515b3317da434cb2b5a4a6ac12257e60b/tests
// --------------------------------------------------------------


// --------------------------------------------------------------
// Utilities
// --------------------------------------------------------------

// Deep compares two recipes after adjusting the format to match the .yaml
// format. 
//
// Specifically, this forces pre-parsed fractions in Qty, just like the canonical tests
// 	e.g. 
//	src = "@carrots{1/2}"
//	results in Qty being 0.5 in the canonical tests (instead of 1/2 with QtyVal=0.5)
// I do wish I could avoid doing this, but interfaces in go are extremely unwieldy
// so I feel this is likely the better approach.
//
// This also inserts `Some` and 1 for cookware to match tests which I did
// not agree with doing during parsing. See the above `NOTE` in this file.
func assertCanonicalRecipe(t *testing.T, got *Recipe, want *Recipe){
	// Push the value into Qty as a string
	for i, ingr := range got.Ingredients {
		if ingr.QtyVal != NoQty {
			got.Ingredients[i].Qty = fmt.Sprintf("%v", ingr.QtyVal)
		} else if ingr.Qty == "" {
			// Include the contentious `some`
			got.Ingredients[i].Qty = "some"
		}
	}
	for i, ware := range got.Cookware {
		if ware.QtyVal != NoQty {
			got.Cookware[i].Qty = fmt.Sprintf("%v", ware.QtyVal)
		} else if ware.Qty == "" {
			// Include the contentious `1`
			got.Cookware[i].Qty = "1"
			got.Cookware[i].QtyVal = 1
		}
	}
	for i, timer := range got.Timers {
		if timer.QtyVal != NoQty {
			got.Timers[i].Qty = fmt.Sprintf("%v", timer.QtyVal)
		} 
	}

	// Repeat the above for Steps
	for i, step := range got.Steps {
		for j, rawChunk := range step {
			var newChunk Chunk
			switch chunk := rawChunk.(type){
			case Text: 
				newChunk = chunk
			case Ingredient:
				if chunk.QtyVal != NoQty {
					chunk.Qty = fmt.Sprintf("%v", chunk.QtyVal)
				} else if chunk.Qty == "" {
					chunk.Qty = "some"
				}
				newChunk = chunk
			case Cookware:
				if chunk.QtyVal != NoQty {
					chunk.Qty = fmt.Sprintf("%v", chunk.QtyVal)
				} else if chunk.Qty == "" {
					chunk.Qty = "1"
					chunk.QtyVal = 1
				}
				newChunk = chunk
			case Timer:
				if chunk.QtyVal != NoQty {
					chunk.Qty = fmt.Sprintf("%v", chunk.QtyVal)
				}
				newChunk = chunk
			default:
				t.Fatalf("Unable to process chunk: %v\n", chunk)
			}
			got.Steps[i][j] = newChunk
		}
	}

	// Now we can compare normally
	if !reflect.DeepEqual(*want, *got) {
		t.Fatalf("Assertion failed:\ngot:\t%+v\nwant:\t%+v", *got, *want)
	}
}

// --------------------------------------------------------------
// Tests
// --------------------------------------------------------------


